using Emgu.CV;
using Emgu.CV.Structure;
using EvilDICOM.Core;
using EvilDICOM.Core.Element;
using EvilDICOM.Core.Helpers;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace DICOMConverter
{
    public class DicomManager
    {
        public List<DICOMObject> ReadAllObjects(string[] dicomFiles)
        {
            List<DICOMObject> dcmObjects = new List<DICOMObject>();

            foreach (var name in dicomFiles)
            {
                dcmObjects.Add(DICOMObject.Read(name));
            }
            return dcmObjects;
        }

        public Image<Gray, double>[] ImagesDicom(DicomManager dcmManager, string[] fileNames, double minValueIntensity, double maxValueIntensity)
        {
            var dcmList = dcmManager.ReadAllObjects(fileNames);

            dcmList = dcmList.OrderBy(dcm => dcm.FindFirst(TagHelper.LOCATION)).ToList();

            var imgs = new Image<Gray, double>[dcmList.Count];

            for (int k = 0; k < dcmList.Count; k++)
            {
                var str = dcmList[k].PixelStream;

                var height = ((UnsignedShort)dcmList[k].FindFirst(TagHelper.ROWS)).Data;
                var width = ((UnsignedShort)dcmList[k].FindFirst(TagHelper.COLUMNS)).Data;

                imgs[k] = new Image<Gray, double>(width, height);

                var bytesPerPixel = ((UnsignedShort)dcmList[k].FindFirst(TagHelper.BITS_ALLOCATED)).Data / 8;

                str.Position = 0;

                var buffer = new byte[width * bytesPerPixel];

                for (int y = 0; y < height; y++)
                {
                    str.Read(buffer, 0, width * bytesPerPixel);

                    for (int x = 0; x < width; x++)
                    {
                        var pixel = imgs[k][x, y];

                        double intensity = 0;

                        for (int i = 1; i < bytesPerPixel + 1; i++)
                        {
                            intensity += buffer[x * bytesPerPixel + bytesPerPixel - i];
                        }

                        if (intensity < maxValueIntensity && intensity > minValueIntensity)
                        {
                            pixel.Intensity = intensity;
                            imgs[k][y, x] = pixel;
                        }
                        else
                        {
                            pixel.Intensity = 0;
                            imgs[k][y, x] = pixel;
                        }
                    }
                }
            }
            return imgs;
        }

        public void Xyz(Image<Gray, double>[] images, double minIntensity, double maxIntensity)
        {
            //double[] norm = new double[3];
            var points = new List<double[]>();
            int count = 0;

            var file = new StreamWriter("C:\\Users\\kochka100\\Desktop\\TestFile.obj");

            for (int z = 0; z < images.Length; z++)
                for (int x = 0; x < images[z].Cols; x++)
                    for (int y = 0; y < images[z].Rows; y++)
                    {
                        if (images[z][x, y].Intensity > minIntensity && images[z][x, y].Intensity < maxIntensity)
                        {
                            points.Add(new double[] { x, y, z });
                            count++;
                            file.Write(x + " " + y + " " + z + "\r\n");
                        }
                    }

            /*foreach(var point in points)
            {
                norm[0] += point[0];
                norm[1] += point[1];
                norm[2] += point[2];
            }

            var d = Math.Sqrt(norm[0] * norm[0] + norm[1] * norm[1] + norm[2] * norm[2]);

            norm[0] /= d;
            norm[1] /= d;
            norm[2] /= d;

            file.Write("####" + "\r\n" + "#" + "\r\n" + "# OBJ File Generated by Meshlab" + "\r\n" + "#" + "\r\n" + "####" + "\r\n");
            file.Write("# Object TestFile.obj" + "\r\n" + "#" + "\r\n" + "#" + " Vertices: " + count + "\r\n" + "#" + " Faces: 0" + "\r\n" + "#" + "\r\n" + "####" + "\r\n");
           
            foreach(var p in points)
            {
                file.Write("vn " + norm[0].ToString("F6") + " " + norm[1].ToString("F6") + " " + norm[2].ToString("F6") + "\r\n");
                file.Write("v " + p[0].ToString("F6") + " " + p[1].ToString("F6") + " " + p[2].ToString("F6") + "\r\n");
                //file.Write(p[0].ToString("F6") + " " + p[1].ToString("F6") + " " + p[2].ToString("F6") 
                    //+ " " + norm[0].ToString("F6") + " " + norm[1].ToString("F6") + " " + norm[2].ToString("F6") + "\r\n");
            }
            file.Write("# " + count + " vertices, 1 vertices normals" + "\r\n" + "\r\n");

            file.Write("f 5639//5639 20//20 3//3" + "\r\n");
            file.Write("f 20//20 5657//5657 3//3" + "\r\n");
            file.Write("5639//5639 5643//5643" + "\r\n");

            file.Write("# 3 faces, 0 coords texture" + "\r\n" + "\r\n");
            file.Write("# End of File");*/
            file.Close();
        }
    }
}
